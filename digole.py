import binasciiimport utime as timedef getTicks_ms():    return time.ticks_ms()def getDeltaTime(t2, t1 = -1):    if (t1 < 0):        t1 = t2        t2 = getTicks_ms()    return time.ticks_diff(t2, t1)   class DigolePrimitive(object):    # generated code to interact with Digole displays etc.    def __init__(self, i2cConnection, address):        self.i2c        = i2cConnection        self.address    = address        self.dataDelay  = 5 # ms (i.e. 40 ms according to documentation)                def _write(self, v):        if (len(v) > 64):            for i in range(0, len(v), 64):                chunk = v[i:i+64]                self._write(chunk)                time.sleep_ms(self.dataDelay)        else:            self.i2c.writeto(self.address, v)            def _readInt(self, n):        raw = self.i2c.readfrom(self.address, n * 2)        return [int.from_bytes(raw[i:i+2], "big") for i in range(0, len(raw), 2)]            def _sendCommand(self, command, *args):        for arg in args:            if type(arg) is bytes:                command += arg            elif type(arg) is str:                command += arg.encode("utf-8") + int(0).to_bytes(1, "big")            elif type(arg) is int:                if arg > 255:                    command += b'\xff'                    arg     -= 255                command += arg.to_bytes(1, "big")        self._write(command)                        def _getFileSize(self, fileName):        # return size in bytes of a file on disk:        with open(fileName, "rb") as f:            f.seek(0, 2) # os.SEEK_END            return f.tell()                    def _sendFile(self, fileName):        # send conent of file on disk as raw data:        with open(fileName, "rb") as f:            while True:                print(end='.')                chunk = f.read(128)                if not chunk:                    print()                    break                self._write(chunk)    def _sendLargeFileSlowly(self, fileName):        size            = self._getFileSize(fileName)        stdDelay        = self.dataDelay        self.dataDelay  = 40        self._write(bytes([size//256, size % 256]))        time.sleep_ms(200) # wait until device is ready        self._sendFile(fileName)        self._write(b'\ff')# indicater of end of it        time.sleep_ms(40)        self.dataDelay  = stdDelay                                    def _checkInt(self, var, varName, hiLimit = 255, loLimit = 0, rangeCheck = True):            assert type(var) is int, "%s is not an integer: %r" % (varName, var)                        if (rangeCheck):                assert loLimit <= var <= hiLimit,"%s fails range check: %d <= [%r] <= %d" % (varName, loLimit, var, hiLimit)            print(loLimit, "<=", "%s(%s)" % (varName, var), "<=", hiLimit)            # --------------------------------------------------------------------------------    #   Text functions    # --------------------------------------------------------------------------------    def displayAsString(self, v):        # Display a string (TTv) (esc = 1)        # Command: TT. following with characters until value 0 received, the value 0 also        # is the terminator of a regular string. This command display a giving string on        # the current position, the position adjusted automatically, if the position reach        # the most right of screen, it move to the beginning of next line of character,        # the module can calculate the next character line according the current using        # font's size.        # The value 10 and 13 (\n and \r in C, LF and CR in ASCII table) can move the        # current position, value 10 move to next line, value 13 move to the beginning of        # current line, use 10 and 13 move to the beginning of next line. Display a string        # (TT...) (esc = 1)        # tested: OK        self._sendCommand(b'TT', ['v'], (), v)    def textReturn(self):        # text return (TRT) (esc = 26)        # tested: OK        self._sendCommand(b'TRT', [], ())    def moveCurrentPosition(self, c, r):        # Move current position(TPxy) (esc = 24)        # Command: TP, followed by c,r position, the c,r value is not refer to pixels, they        # are the column and row value that MCU calculated based on the font's size        # (usually use space size to calculate current font's size). The top-left position        # is: 0,0.        # tested: OK        self._sendCommand(b'TP', ['c', 'r'], (), c, r)    def enhancedMoveCurrentPosition(self, x, y):        # Enhanced move current position(ETPxy)  (esc = 3)        # Command:ETP followed by x,y position in pixels, this function can adjust the text        # position as pixels on screen. The top-left position is: 0,0.        # tested: ONLY WORKS WELL IN VERTICAL DIRECTION; HORIZONTALLY THERE IS UNCONTROLLED        #         SCALING        self._sendCommand(b'ETP', ['x', 'y'], (), x, y)    def movePositionToLast(self):        #_Move position to last(ETB) (esc = 2)        # Command:ETB. after each character printed on screen, the current position is        # adjust to new value, the MCU also remembered the last character's position, if        # you want print few characters at same position, you can use this function. eg.:        # print a bold K, the command sequence is: "TTK\x00ETB ETO\x02\x00TTK", in here we        # use move position offset command, it move the last position 2 pixels right.        # tested: OK        self._sendCommand(b'ETB', [], ())    def movePositionOffset(self, x, y):        # Move position offset(ETOxy)  (esc = 4)        # Command: ETO, followed by x,y value in pixels, the range of x,y value is -127~127,        # it adjust the current position with the relative value. eg.: if current position        # is 46, 30, and the x=-10, y=5. after run this command, the new position        # is:36,35.        # tested: OK        self._sendCommand(b'ETO', ['x', 'y'], (), x, y)    def textcursor(self, f):        # TextCursor(CSf)  (esc = 30)        # Command: CS, followed by a value 0 or 1, if f=1, the module will show a small        # cursor at the current position, otherwise, no cursor displayed.        # Sorry, the cursor on function not always work properly for some reason, for        # example, when the cursor show up, you clear the area where cursor in, the cursor        # is disappeared, but the module still think it's show up, this will make it        # massed when module blinking the cursor.        # tested: no effect seen        self._sendCommand(b'CS', ['f'], (), f)    def __textAlignment(self, align):        #_Text Alignment(ALIGNd)  (esc = 62)        # Command: ALIGN, follow a value 0,1 or 2, indicate how to align the text based on        # the current position in the on coming display string (TT) command, value 0=left        # alignment (default), 1=middle alignment, 2=right alignment.        # tested: seems to have no effect at all (V4.2) -- WdW        self._sendCommand(b'ALIGN', ['align'], (0, 2), align)    # --------------------------------------------------------------------------------    #   Graphics    # --------------------------------------------------------------------------------    def setCurrentGraphicPosition(self, x, y):        # Set current graphic position(GPxy)  (esc = 27)        # Command:GP, followed by x,y value in pixels, this function is same with "ETP"        # since firmware V3.0 and later, but, in older version before V3.0, the CGP and        # text position are separated.        # tested: OK        self._sendCommand(b'GP', ['x', 'y'], (), x, y)    def drawPixel(self, x, y):        # Draw a pixel(DPxy)  (esc = 20)        # Command:DP, followed by x,y value in pixels. This function draw a pixel at (x,y)        # position using foreground color (set by commands "SC" or "ESC"), the pixel also        # logic operate(draw mode, set by "DM" command) with existing pixel at same        # position. This function doesn't change CGP.        # tested: OK        self._sendCommand(b'DP', ['x', 'y'], (), x, y)    def drawLine(self, x1, y1, x2, y2):        # Draw line (LNx1y1x2y2)  (esc = 16)        # Command:LN, followed by two coordinates which indicate where the line drawing from        # and to (x1,y1)(x2,y2) in pixels, the foreground color and draw mode affect this        # function, also affected by line pattern (set by command "SLP"). The CGP also        # moves to (x2,y2) after function executed.        # eg.: draw a line from (30,40) to (200,300), the command sequence is this:        # "LN\x1E\x28\xC8\xFF\x2D", because the value of 300 exceed one byte, you need use        # 2 bytes format.        # tested: OK        self._sendCommand(b'LN', ['x1', 'y1', 'x2', 'y2'], (), x1, y1, x2, y2)    def drawLineTo(self, x, y):        # Draw line to(LTxy)  (esc = 17)        # Command:LT, followed by the destination coordinate (x,y) in pixels, this function        # draw a line from current position to (x,y), everything else same as "draw line"        # function.  The CGP moves to (x,y).        # tested: OK        self._sendCommand(b'LT', ['x', 'y'], (), x, y)    def drawRectangle(self, x1, y1, x2, y2):        # Draw rectangle(DRx1y1x2y2) (esc = 21)        # Command: DR, followed by the top-left coordinate (x,y), and the right-bottom        # coordinate, all in pixels, this function affect  by foreground color, draw mode        # and line pattern.  The CGP move to (x2,y2).        # tested: OK        self._sendCommand(b'DR', ['x1', 'y1', 'x2', 'y2'], (), x1, y1, x2, y2)    def drawFilledRectangle(self, x1, y1, x2, y2):        # Draw filled rectangle(FRx1y1x2y2) (esc = 15)        # Command: FR, this function similar with "draw rectangle", but will use current        # foreground color, draw mode and line  pattern to fill this rectangle.  The CGP        # moves to (x2,y2).        # tested: OK        self._sendCommand(b'FR', ['x1', 'y1', 'x2', 'y2'], (), x1, y1, x2, y2)    def drawCircle(self, x, y, r, f):        # Draw circle(CCxyrf) (esc = 29)        # Command: CC, followed by the coordinate of circle center(x,y), then the radius,        # the "f" is indicate the circle is filled or  not, if f=1, the circle is filled,        # this function is affected by foreground color and draw mode, but not affected by        # line pattern.  The CGP move to (x,y).        # tested: OK        self._sendCommand(b'CC', ['X', 'Y', 'r', 'f'], (), x, y, r, f)    def drawImage(self, mode, x, y, w, h, imageData):        # Command: [e]DIM[m], followed by the top-left coordinate (x,y) of the image, then image         # width (w), height (h), then follow the image data (...d...). For details, please refer         # to the manual        # tested: OK        if mode == 0:            self._sendCommand(b'DIM', ['x', 'y', 'w', 'h', 'imageData'], (), x, y, w, h, imageData)        else:            assert imageData is None or (len(imageData) == mode * w * h), "image data size mismatch"            self._sendCommand(b'EDIM' + bytes([mode + 48]), ['x', 'y', 'w', 'h', 'imageData'], (), x, y, w, h, imageData)                def drawImageFile(self, mode, x, y, w, h, fileName):        # see drawImage, only data are read from file, thus saving a lot of memory.        # tested: OK        size = self._getFileSize(fileName)        assert (size == mode * w * h), "image file data size mismatch"        # only now send introduction, for open file might fail and then the display keeps waiting for         # a load of data (if this happens, keep writing strings until they are diaplayed)        self.drawImage(mode, x, y, w, h, None)                self._sendFile(fileName)            def videoBox(self, x, y, w, h, f, videoData):        # Video Box (VIDEOxywh/....data) (esc = 61)        # This command let user to send raw image data to the LCD panel directly, after        # command "VIDEO", followed by 2 integer data x, y to indicate the top-left position        # counted as pixels where of the video box, the available value of x,y are from 0        # to 65535 but not exceed the LCD panel size, then 2 bytes of value to indicate        # the box width and height, the available value are from 0 to 255.        # After defined the video box, the next byte of value indicate the color depth of        # each pixel, if value is 0, the color depth is 16BIT(2 bytes data)        # NOT tested        self._sendCommand(b'VIDEO', ['x', 'y', 'w', 'h', 'f', 'videoData'], (), x, y, w, h, f, videoData)    def moveArea(self, x, y, w, h, ox, oy):        # Move area on the screen(MAxywhOxOy) (esc = 32)        # Command: MA, followed by the top-left coordinate of the area, then the area width        # and height, all as pixels the Ox, and Oy are the offset refers to (x,y), it will        # move the area(x,y)-(x+width,y+height) to new top-left position of(x+Ox,y+Oy),        # the value of Ox, Oy are -127~127.        # This function is useful to scroll screen in 4 directions.        # tested: OK        self._sendCommand(b'MA', ['x', 'y', 'w', 'h', 'ox', 'oy'], (), x, y, w, h, ox, oy)    # --------------------------------------------------------------------------------    #   Graphic Settings    # --------------------------------------------------------------------------------    def clearScreen(self):        # Clear screen(CL)  (esc = 28)        # Command:CL, clear the screen panel: use current background color to clear the        # screen.  This function also reset current font to 0, screen rotation to 0, x        # position to 0, draw mode to 'C', draw window to full  screen, line pattern to        # 0xff.        # tested: OK        self._sendCommand(b'CL', [], ())    def setBackgroundColor(self, color):        # Set background color(BGC)  (esc = 53)        # Command: BGC, specify the one byte value of color (256 color depth,332 format)        # follow this command. eg.: set a red  background: "BGC\xE0".        # tested: OK        # WARNING: with a light background the display draws more current; if the supply        #          stalls, it may freeze in an error state.        self._sendCommand(b'BGC', ['color'], (0, 255), color)    def setForegroundColor(self, c):        # convenience method        # tested: OK        if isinstance(c, tuple) or isinstance(c, list):            self.setForegroundColorRGB(*c)        else:            self.setForegroundColor256(c)                            def setForegroundColor256(self, b):        # Set foreground color(SCc) (esc = 5)        # There are 2 commands to set foreground color: "SC" then follow by a byte to set        # 256 color depth, and "ESC" follow by 3 bytes to set 262K color depth. Only 2        # different value for these display module: 0 and 1.        # tested: OK        self._sendCommand(b'SC', ['b'], (), b)    def setForegroundColorRGB(self, b):        # Set foreground color(ESCrgb) (esc = 7)        # There are 2 commands to set foreground color: "SC" then follow by a byte to set        # 256 color depth, and "ESC" follow by 3 bytes to set 262K color depth. Only 2        # different value for these display module: 0 and 1.        # tested: OK        self._sendCommand(b'ESC', ['b'], (), b)    def setLinePattern(self, b):        # Set line pattern(SLPb)  (esc = 14)        # Command: SLP, followed by a byte indicate which pixel should display or not, there        # are 8 bits in a byte, so when  drawing line, the module will repeat every 8 bits        # according to the line pattern value.  eg.: "SLP\x55" command will let the draw        # line/rectangle function to draw a dotted line, because "\x55" equal: 0B01010101,        # if the bit is 0, that pixel will not displayed.  If the line pattern value is:        # 0B11010111, the drawing line is dashed.        # tested: OK        self._sendCommand(b'SLP', ['b'], (), b)    def setDrawDirection(self, direction):        # Set draw direction(SDdir) (esc = 9)        # Command: SD, then follow by the 0,1,2,3 direction you want, the original        # direction is 0, direction 1,2,3 represent  90,180 and 270 degree clockwise(also        # means turn display panel anti-clockwise). if the value out of {0~3}, the final        # direction is: d%4, means, value 4 is 0 direction, and 5 is 1 direction...        # tested: OK        self._sendCommand(b'SD', ['direction'], (0, 3), direction)    def setDrawMode(self, s):        # Set draw mode(DMmode)  (esc = 35)        # Command: DM, followed by a byte of draw mode which only one letter can be used        # from {C,|,!,~,&,^,O,o}. Draw mode is  used to tell the module how to display the        # color of pixel using current foreground color operating with the existing pixel,        # there are 6 modes available:  'C'-Copy, doesn't matter the existing pixel on        # screen, this mode use current foreground color to over _write the pixel,  for        # "TT" command, it also clear the char box as back ground color, all other modes        # will not clear the char box.        # tested: OK        self._sendCommand(b'DM', ['s'], (), s)    def setDrawWindow(self, x, y, w, h):        # Set output/draw window(DWWINxywh)  (esc = 54)        # Draw window was embedded since firmware version 3.2 and later, instead of output        # to full screen, user can set a smaller rectangle area as draw window, then all        # following output will be showing in this window and the coordinate also refers        # to the top-left corner of draw window. This ability provide user a new way to        # relocate an area of content on the screen to different location easily, just        # change the draw window to the desired location, then done. Command: DWWIN,        # follow by top-left        # coordinate value (x,y), then draw window's width (w) and height (h) all value in        # pixels.        # tested: OK        self._sendCommand(b'DWWIN', ['x', 'y', 'w', 'h'], (), x, y, w, h)    def resetDrawWindow(self):        # Reset draw window(RSTDW)  (esc = 55)        # Command: RSTDW; remove the current draw window, what the module do is set the        # new draw window to full screen.        # tested: OK        self._sendCommand(b'RSTDW', [], ())    def clearDrawWindow(self):        # Clear draw window(WINCL)  (esc = 56)        # Command: WINCL, clear the draw window use background color.        # tested: OK        self._sendCommand(b'WINCL', [], ())    def setImageBackgroundTransparent(self, f):        # Set image's background transparent (TRANS 0/1)  (esc = 60)        # When we show an image (256, 65K or 262K color) on the screen, the image occupy a        # rectangle area, this command can change the image shape on the screen, the black        # pixels in the rectangle area can be transparent, in order to do this, just set        # the color to be black (00) where want it to be transparent, then set "TRANS\x01"        # command, here is our logo shows on a blue background when TRANS=0 and TRANS=1:        self._sendCommand(b'TRANS', ['f'], (), f)    # --------------------------------------------------------------------------------    #   Monochrome    # --------------------------------------------------------------------------------    def refreshScreenInstantly(self, f):        # Refresh screen instantly(FSf)  (esc = 37)        # Command: FS, followed by a byte of value 0 or 1. if value is 0, the module will        # not refresh the screen until it receive a  fresh screen command such as "FS2",        # if the value is 1, the module will refresh the screen from internal screen        # buffer  to screen when the module is idle (no more pending commands in receiving        # buffer) automatically.  This command only available on Black/White display        # module, the color module always refresh the screen instantly  because no screen        # buffer used in onboard MCU.  If you need update the screen rapidly, disable the        # auto-refresh will help to avoid the screen flicking: draw all  information to        # the screen buffer in MCU, the refresh the screen at once.        # NOT tested, should work on BW display only        self._sendCommand(b'FS', ['f'], (), f)    def setScreenInverse(self, f):        # Set screen Normal/Inverse(INV0/1)  (esc = 40)        # Command:INV, follow a byte of value 0 or 1 to indicate the screen content normal        # or inverse, this command only  available on some monochrome module, and the        # content is affected instantly.        # tested: no effect on colour screen, should work on BW display only        self._sendCommand(b'INV', ['f'], (), f)    # --------------------------------------------------------------------------------    #   Font management    # --------------------------------------------------------------------------------    def changeCurrentFont(self, b):        # Change current font(SFd)  (esc = 10)        # tested: OK        self._sendCommand(b'SF', ['b'], (), b)    def downloadUserFont(self, index, fileName):        self.downloadStdUserFont(index, fileName)            def downloadStdUserFont(self, index, fileName):        # Download standard user font(SUFnLd) (esc = 12)        # (You can use "SF"+200~203 command to use these fonts which downloaded by this        # command). Command: SUF, followed by a byte of the index number of user font space,        # then 2 bytes of data length of font, then the font data. 40ms delay is needed        # after each 64 bytes of data send out, refer "Write data to flash" command        self._getFileSize(fileName) # file eror, then crash before sending the next command        self._sendCommand(b'SUF', ['index'], (200, 203), index)        self._sendLargeFileSlowly(fileName)    def useUserFontInFlashChip(self, address):        # Use user font in flash chip(SFFa)" "        # Command: SFF, follow by 3 bytes of address which the font data in flash chip start from.        self._sendCommand(b'SFF', ['address'], (), address)                    # --------------------------------------------------------------------------------    #   Command sets    # --------------------------------------------------------------------------------    def runCommandSet(self, a):        # Run command set(FLMCSa)  (esc = 52)        # Command: FLMCS, followed by 3 bytes of address which indicate the beginning of        # command set, 3 bytes address format allow the module access all 2MB memory in        # flash chip.        self._sendCommand(b'FLMCS', ['a'], (), a)    # --------------------------------------------------------------------------------    #   EEPROM utilities    # --------------------------------------------------------------------------------    def writeDataToEeprom(self, a, l, data):        # Write data to EEPROM(WREPal...d...) (esc = 38)        # Command: WREP, followed by 2 bytes of address, 2 bytes of data length (MSB-LSB        # format), then the data.        self._sendCommand(b'WREP', ['a', 'l', 'data'], (), a, l, data)    def readDataFromEeprom(self, a, l):        # Read data from EEPROM(RDEPal)  (esc = 39)        # Command: RDEP, followed by 2 bytes of address, 2 bytes of data length (MSB-LSB        # format), after these 8 bytes of  command sent to the module, the master        # controller need to wait the data available on the communication port, read  out        # all desired data from the port.        self._sendCommand(b'RDEP', ['a', 'l'], (), a, l)    # --------------------------------------------------------------------------------    #   FLASH utilities    # --------------------------------------------------------------------------------    # If the flash chip installed onboard, you can use the full 2MB~16MB flash chip to     # store welcome screen, user font, command set and user data, all data in flash chip     # can be read out. The flash in MCU becomes unusable.    # If there is no flash chip installed onboard, you can use the 16KB flash, user canÂ’t     # read out the data saved in the internal flash memory.        def writeDataToFlash(self, a, l, data):        # Write data to flash(FLMWRal...d...)  (esc = 51)        # This command applicable to internal 16KB flash or external flash chip. Command:        # FLMWR, followed by 3 bytes of start address, 3 bytes of data length (MSB, LSB        # format), then the data. This command can write data to flash chip or internal        # flash memory.        self._sendCommand(b'FLMWR', ['a', 'l', 'data'], (), a, l, data)    def readDataInFlashChip(self, a, l):        # Read data in flash chip(FLMRDal)  (esc = 59)        # This command only applicable to external flash chip. If the flash chip installed        # on the board, you can use it to save user data, and read the data when you need        # it. Command: FLMRD, followed by 3 bytes of address, then 3 bytes of data length,        # all MSB format. After this command issued, the master controller can read data        # from the communication port when data in module ready        self._sendCommand(b'FLMRD', ['a', 'l'], (), a, l)    def eraseFlashMemoryInFlashChip(self, a, l):        # Erase flash memory in flash chip(FLMERal) (esc = 49)        # This command only applicable to external flash chip.        # Only writing data to flash chip need this command, this command can erase only        # specific range of address on all ! color module. Because the erasing on the chip        # is operating as block, the module will save the useful data in the block to the        # RAM on screen panel, erase whole block, then restore the useful data back, so,        # you may see a block of screen at the left-bottom corner show some wild image,        # that is the data from the erased block        self._sendCommand(b'FLMER', ['a', 'l'], (), a, l)    # --------------------------------------------------------------------------------    #   Touch panel    # --------------------------------------------------------------------------------    def calibrateTouchScreen(self):        # Calibrate touch screen(TUCHC) (esc = 45)        # tested: OK        self._sendCommand(b'TUCHC')    def readTouchScreen(self):        # Read touched coordinate(RPNXYW)" "        # After module received this command, the module will waiting until the touch panel pressed         # down, and then send the touched position which mapped to screen pixel’s coordinate back to         # master (x,y), alway return 4 bytes, 2 integer value, x first then y.        self._sendCommand(b'RPNXYW')                            def readClick(self):        # Read a click event(RPNXYC)" "        # Similar with above function, but the module will return the coordinate data after touch panel released.        self._sendCommand(b'RPNXYC')        def checkTouchScreen(self):        # Read touch panel instantly(RPNXYI), check screen pressed" "        # The 2 functions above will drive the module frozen until the touch screen pressed. If you         # only want to check the touch screen pressed or not, this is the function for the software,         # it returns a pair of out of range value of no press on touch screen.        # You also can check a hardware signal on the module when screen pressed, there is a PENIRQ         # signal on the 9pin header, this signal will go low when screen pressed. This is the easiest         # way to quote the touch screen if there were a free I/O pin on your master controller.        self._sendCommand(b'RPNXYI')        def readVoltage(self):        # Read voltage(RDBAT) (esc = 46)        # Connect a voltage on the Vbat pin on the 9pin header, then send command: RDBAT        # to module, the module will  return 2 bytes of data of voltage on the Vbat pin,        # MSB format, the unit is mV, the range is 0~10,000. eg.: if the 2 bytes  of value        # is: 18, 192, the voltage is: 18x256+192=4800mV, is 4.8V.  The input impedance        # is: 10kO! Hint: if the measured voltage is over 10V, a 2R voltage divider is        # needed.        self._sendCommand(b'RDBAT', [], ())    def readAnalog(self):        # Read analog(RDAUX) (esc = 47)        # Connect the analog to the AUX pin on the 9pin header, then use this command to        # read it, we didn't adjust the 2 bytes result here, the data range is 0~4095, and        # represent 0~2.5V. Use this format to calculate the real voltage: V=d*2.5/4096.        # (d is the reading data)        self._sendCommand(b'RDAUX', [], ())    def readTemperature(self):        # Read temperature(RDTMP) (esc = 48)        # This command read the temperature of the chip, the format to calculate the        # temperature is: T=(653-(d*2500/4096))/2.1 degree C, d is the reading data. Note,        # the temperature on the chip may be affected by the backlight heat of LCD screen.        self._sendCommand(b'RDTMP', [], ())    # --------------------------------------------------------------------------------    #   Power management    # --------------------------------------------------------------------------------    def backlightBrightness(self, percentage):        # Backlight brightness(BLd)  (esc = 25)        # The backlight brightness on all color LCD and MonoChrome GLCD modules! can be        # adjusted continuously by use command: BL, followed by a byte of value 0~100, 0        # will turn backlight full off, and 100 will turn backlight full on. The backlight        # on all OLED modules are not adjust-able.        # tested: OK        self._sendCommand(b'BL', ['percentage'], (0, 100), percentage)    def turnScreenOn(self, f):        # Turn screen on        # Command: SOO, followed by a byte value 0/1, when d=0, the screen and the backlight        # will be turned off immediately,  that will save much power on the module, this        # function work on all module.  On most of modules, the module only consume few mA        # after screen turned off.  The content on the screen unchanged if screen turn off        # then turn on later.        self._sendCommand(b'SOO', ['f'], (), f)    def turnMcuOff(self):        # Turn MCU off(DNMCU)  (esc = 42)        # Command: DNMCU, no following data needed, the module will check if there were more         # pending commands in buffer before entering sleep. If there were, the module will not         # enter sleep mode. The module wakes up automatically when new data are received, but if         # the COM mode is I2C, some dummy data are needed to act as waking signal, so, use few         # write(0) then a delay 10ms is a good practice to wake up the MCU from deep sleep.        # The screen will keep on, and all content on the screen unchanged when MCU off.        self._sendCommand(b'DNMCU', [], ())    def turnModuleOff(self):        # Turn module off(DNALL)  (esc = 41)        # This command put all power off: backlight off, screen off, MCU enter deep sleep,        # the module will only consume <0.05mA of current, the wake up sequence is same        # with wake up MCU, the module will restore backlight and put screen on also after        # wake up, the content on the screen unchanged.        # tested: OK        self._sendCommand(b'DNALL', [], ())    def turnBackOn(self):        self._sendCommand(b'\x00\x00\x00\x00', [], ())    # --------------------------------------------------------------------------------    #   Configuration    # --------------------------------------------------------------------------------    def downloadStartScreenToModule(self, fileName):        # Download start screen to module(SSSl...d...)  (esc = 11)        # Command: SSS, followed by 2 bytes of data length of start screen, then the data,        # as described before, the data  structure are different for monochrome module and        # color module.  In V3.2 and earlier version on color module, the command set also        # need 2 bytes of data to indicate the command set  length, when you downloading        # this format of start screen to module, 2 bytes of length follow to SSS to        # indicate the  length of rest data, and in the rest of data, the first 2 bytes to        # indicate the length of command set, their relationship is:  SSS (length+2)        # (length) (...data...).        self._getFileSize(fileName) # file eror, then crash before sending the next command        self._sendCommand(b'', [], ())        self._sendLargeFileSlowly(fileName)    def setSpiMode(self, mode):        # Set SPI mode(SPIMD0~3) (esc = 57)        # There are 4 mode for SPI, based on the Clock polarity and phase, the default is        # mode 0 (except V3.3, was mode 2). Command: SPIMD, follow a byte to indicate the        # new SPI mode, the module will use the new mode on next power up. This command        # only available on firmware V3.4 and later.        self._sendCommand(b'SPIMD', ['mode'], (0, 3), mode)    def configurationShow(self, f):        # Configuration show on/off(DCd)  (esc = 18)        # In default, the module will show start screen when power on, and also show the        # current COM mode after start screen showed up, that will tell you what is the        # Baud on UART mode or the slave address on I2C mode. If you want to manage this        # configuration show on the screen, use command: DC, then follow by a byte value 0        # or 1, if d=0, the configuration will not show on the screen on next power on.        self._sendCommand(b'DC', ['f'], (), f)    def enableStartScreen(self, f):        # Enable/disable start screen(DSSd)  (esc = 22)        # Command: DSS, if the following value is 0, the start screen is not show up on        # next power on.        self._sendCommand(b'DSS', ['f'], (), f)    def changeI2Caddress(self, b):        # Change I2C address(SI2CAa) (esc = 6)        # When you connect multiple modules on a I2C bus, every slave modules MUST be        # assigned with different address, this function can change the default address of        # 0x27 to other value. This command only work at I2C COM mode, you can't use it at        # UART or SPI mode. Command: SI2CA, followed by a byte of new address. The module        # use the new address instantly, it also save this new address in internal memory,        # you don't need to change it on the next power recycle.        self._sendCommand(b'SI2CA', ['b'], (), b)    def adjustLCDcontrast(self, percentage):        # (undocumented) (esc = 31)        # Adjust LCD contrast(CTx)"        # Command:CT, followed by a byte of value 0~100, this command only effective for        # 128*64 GLCD with ST7565 controller, The contrast on GLCD use KS0108 and ST7920        # controller only be adjustable by a hardware pot.        self._sendCommand(b'CT', ['percentage'], (0, 100), percentage)    def configUGLCDadapter(self, b1, b2, b3, b4, b5, b6, b7, b8):        # Config universal graphic LCD adapter(SLCDx...) (esc = 43)        # see manual        self._sendCommand(b'SLCD', ['b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8'], ((166, 167), (162, 163), (160, 161), (192, 200), (32, 39), (129, 129), (0, 63), (64, 127)), b1, b2, b3, b4, b5, b6, b7, b8)    # --------------------------------------------------------------------------------    #   other functions    # --------------------------------------------------------------------------------    def delayAPeriod(self, b):        # Delay a period(DLYx)  (esc = 59)        # This command only available since V3.9, but this is a bug in V3.9: it will be        # halt if on I2C/SPI mode, fixed in V4.0. Command: "DLY",        # following with a byte of delay period, value 1 for about 0.25s.        self._sendCommand(b'DLY', ['b'], (), b)    def __sendCommandToScreen(self, b):        # send command to screen (MCD) (esc = 33)        # (undocumented, "manualCommand" in arduino-lib)        # test: causes display to blackout until next power-on        self._sendCommand(b'MCD', ['b'], (), b)    def sendDataToScreen(self, b):        # send data to screen (MDT) (esc = 34)        # (undocumented, "manualData" in arduino-lib)        self._sendCommand(b'MDT', ['b'], (), b)                class DigoleDisplay(DigolePrimitive):        def __init__(self, i2cConnection, address):        super().__init__(i2cConnection, address)        # add buffers for handling of incoming events:        self._waitBuffer= []        self._inBuffer  = []        def _print(self, *args, end="\r\n"):        # print to display; syntax like python's print():        if len(args) == 0: args = [""]        self.displayAsString(" ".join([str(arg) for arg in args]))        self.displayAsString(end)        # redefine read functions to handle responses from the device:        def checkTouchScreen(self):        DigolePrimitive.checkTouchScreen(self)        self._waitBuffer.append('CLICK', 2, getTicks_ms())    def readAnalog(self):        DigolePrimitive.readAnalog(self)        self._waitBuffer.append('ANAL', 1, getTicks_ms())            def readClick(self):        DigolePrimitive.readClick(self)        self._waitBuffer.append('CLICK', 2, getTicks_ms())            def readTemperature(self):        DigolePrimitive.readTemperature(self)        self._waitBuffer.append('TEMP', 1, getTicks_ms())            def readTouchScreen(self):        DigolePrimitive.readTouchScreen(self)        self._waitBuffer.append('CLICK', 2, getTicks_ms())            def readVoltage(self):        DigolePrimitive.readVoltage(self)        self._waitBuffer.append('VOLT', 1, getTicks_ms())                            # function to be called at intervals to detect response events:    def doCheck(self):        try:            #ib = self.i2c.readfrom(self.address, 2)            ii = self._readInt(1)            if (ii[0] < 0xfff0):                self._inBuffer += ii                    except OSError as e:            if not "ETIMEDOUT" in str(e):                raise                    result = []        for opcode, argCount, timeStamp in self._waitBuffer:            if getDeltaTime(timeStamp) > 2000: # 2 sec timeout                self._waitBuffer.pop(0)                continue                        if len(self._inBuffer) < argCount:                break                        args = [self._inBuffer.pop(0) for i in range(argCount)]                                    if (opcode=="CLICK"):                if (args[0] > 1000):                    # reject event:                    continue                        if (opcode=="ANAL"):                # the real voltage: V=d*2.5/4096. (d is the reading data)                volt = args[0] * 2.5/4096.                 temp = (653-(args[0] * 2500./4096.))/2.1                args.insert(0, temp)                            if (opcode=="TEMP"):                # T=(653-(d*2500/4096))/2.1 °C, d is the reading data.                temp = (653-(args[0] * 2500./4096.))/2.1                args.insert(0, temp)                            result.append((opcode, args))            if (self._waitBuffer == []):            self._inBuffer = []            return result    # while True:#   d.readClick()#   print(end='.')#   time.sleep_ms(500)#   msgs = d.doCheck()#   if msgs != []:#     print()#     print(msgs)#     break#     #   if (d._waitBuffer == []):#     break#     